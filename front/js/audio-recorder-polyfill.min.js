/*
 * Audio Recorder Polyfill
 * https://github.com/ai/audio-recorder-polyfill
 */

let waveEncoder = require('./wave-encoder')

let AudioContext = window.AudioContext || window.webkitAudioContext

let createWorker = code => {
  let url = URL.createObjectURL(new Blob([code]))
  let worker = new Worker(url)
  URL.revokeObjectURL(url)
  return worker
}

let error = event => {
  if (event.name === 'InvalidStateError') {
    throw new Error('Recording context was not started')
  } else {
    throw event
  }
}

let processWebWorker = createWorker(`
  let waveEncoder = ${waveEncoder.toString()}
  let recLength = 0
  let recBuffers = []

  onmessage = e => {
    switch (e.data.command) {
      case 'init':
        init(e.data.config)
        break
      case 'record':
        record(e.data.buffer)
        break
      case 'export':
        exportData()
        break
      case 'clear':
        clear()
        break
    }
  }

  function init (config) {
    recLength = 0
    recBuffers = []
  }

  function record (buffer) {
    recBuffers.push(buffer)
    recLength += buffer.length
  }

  function exportData () {
    let buffer = mergeBuffers(recBuffers, recLength)
    let dataview = waveEncoder(buffer)
    let audioBlob = new Blob([dataview], { type: 'audio/wav' })
    postMessage(audioBlob)
  }

  function clear () {
    recLength = 0
    recBuffers = []
  }

  function mergeBuffers (recBuffers, recLength) {
    let result = new Float32Array(recLength)
    let offset = 0
    for (let i = 0; i < recBuffers.length; i++) {
      result.set(recBuffers[i], offset)
      offset += recBuffers[i].length
    }
    return result
  }
`)

class MediaRecorder {
  constructor (stream, options = {}) {
    this.stream = stream
    this.config = {
      audioBitsPerSecond: options.audioBitsPerSecond,
      mimeType: options.mimeType || 'audio/wav'
    }

    this.state = 'inactive'
    this.chunks = []
    this.ondataavailable = () => {}
    this.onstop = () => {}

    this.context = new AudioContext()
    this.processor = this.context.createScriptProcessor(16384, 1, 1)
    this.processor.connect(this.context.destination)

    this.worker = processWebWorker
    this.worker.postMessage({
      command: 'init',
      config: this.config
    })

    this.worker.onmessage = e => {
      let event = new Event('dataavailable')
      event.data = e.data
      this.ondataavailable(event)
      this.onstop()
    }
  }

  start (timeslice) {
    if (this.state !== 'inactive') {
      return error({ name: 'InvalidStateError' })
    }

    this.state = 'recording'

    this.source = this.context.createMediaStreamSource(this.stream)
    this.source.connect(this.processor)

    this.processor.onaudioprocess = e => {
      if (this.state === 'recording') {
        this.worker.postMessage({
          command: 'record',
          buffer: e.inputBuffer.getChannelData(0)
        })
      }
    }

    if (timeslice) {
      this.slicing = setInterval(() => {
        if (this.state === 'recording') this.requestData()
      }, timeslice)
    }

    return undefined
  }

  stop () {
    if (this.state === 'inactive') {
      return error({ name: 'InvalidStateError' })
    }

    this.requestData()
    this.state = 'inactive'
    this.processor.disconnect()
    this.source.disconnect()

    return undefined
  }

  pause () {
    if (this.state !== 'recording') {
      return error({ name: 'InvalidStateError' })
    }

    this.state = 'paused'
    return undefined
  }

  resume () {
    if (this.state !== 'paused') {
      return error({ name: 'InvalidStateError' })
    }

    this.state = 'recording'
    return undefined
  }

  requestData () {
    if (this.state === 'inactive') {
      return error({ name: 'InvalidStateError' })
    }

    this.worker.postMessage({ command: 'export' })
  }

  static isTypeSupported (type) {
    return type === 'audio/wav'
  }
}

module.exports = MediaRecorder
